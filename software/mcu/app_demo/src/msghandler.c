/*
 * Copyright (c), NXP Semiconductors
 * (C)NXP B.V. 2014-2017
 * All rights are reserved. Reproduction in whole or in part is prohibited without
 * the written consent of the copyright owner. NXP reserves the right to make
 * changes without notice at any time. NXP makes no warranty, expressed, implied or
 * statutory, including but not limited to any implied warranty of merchantability
 * or fitness for any particular purpose, or that the use will not infringe any
 * third party patent, copyright or trademark. NXP must not be liable for any loss
 * or damage arising from its use.
 */


#include <string.h>
#include "msg/msg.h"
#include "ndeft2t/ndeft2t.h"
#include "storage/storage.h"
#include "tmeas/tmeas.h"
#include "memory.h"
#include "timer.h"
#include "text.h"
#include "msghandler.h"
#include "msghandler_protocol.h"

/* ------------------------------------------------------------------------- */

static uint32_t GetMeasurementsHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t GetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t SetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t MeasureTemperatureHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static bool ResponseCb(int responseLength, const uint8_t* responseData);

/* ------------------------------------------------------------------------- */

/**
 * Used to block multiple responses on one command. Communication must occur strictly according
 * to a command - response sequence. Multiple responses generated by one command are to be fetched
 * using #MSG_ID_GETRESPONSE - I'm thinking here of #APP_MSG_ID_MEASURETEMPERATURE in particular.
 */
static bool sAcceptResponse = false;

__attribute__ ((section(".noinit")))
uint8_t App_ResponseBuffer[MSG_RESPONSE_BUFFER_SIZE];

MSG_CMD_HANDLER_T App_CmdHandler[MSG_APP_HANDLERS_COUNT] = {{APP_MSG_ID_GETMEASUREMENTS, GetMeasurementsHandler},
                                                            {APP_MSG_ID_GETCONFIG, GetConfigHandler},
                                                            {APP_MSG_ID_SETCONFIG, SetConfigHandler},
                                                            {APP_MSG_ID_MEASURETEMPERATURE, MeasureTemperatureHandler}};

/* ------------------------------------------------------------------------- */

static uint32_t GetMeasurementsHandler(uint8_t msgId, int len, const uint8_t * pPayload)
{
    /* The maximum message size we can create is 512 bytes big - including all NDEFT2T overhead. A single record
     * message has ?44? bytes overhead.
     * As payload, we store a APP_MSG_RESPONSE_GETMEASUREMENTS_T structure followed by a sequence of measurement
     * values, two bytes per value.
     * This gives a maximum of (512 - ?44? - sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T)) / 2 = ?228? values
     * The structure APP_MSG_RESPONSE_GETMEASUREMENTS_T is guaranteed to be 16-bit aligned.
     */
#define MAX_NR_OF_VALUES_IN_RESPONSE 225
#if MAX_NR_OF_VALUES_IN_RESPONSE > 255
#error MAX_NR_OF_VALUES_IN_RESPONSE must fit in one byte
#endif
    __attribute__ ((section(".noinit"))) __attribute__((aligned (2)))
    static uint8_t sBuffer[sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T)
            + (sizeof(uint16_t) * MAX_NR_OF_VALUES_IN_RESPONSE)];

    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_GETMEASUREMENTS_T)) {
        const APP_MSG_CMD_GETMEASUREMENTS_T * p = (const APP_MSG_CMD_GETMEASUREMENTS_T *)pPayload;

        /* Fill in the response structure. */
        APP_MSG_RESPONSE_GETMEASUREMENTS_T * response = (APP_MSG_RESPONSE_GETMEASUREMENTS_T *)sBuffer;
        response->offset = p->offset;
        memset(response->zero, 0, sizeof(response->zero));
        /* Append with the determined number of measured values. */
        STORAGE_TYPE * data = (STORAGE_TYPE *)&sBuffer[sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T)];
        if (Storage_Seek((int)response->offset)) {
            int count = Storage_Read(data, MAX_NR_OF_VALUES_IN_RESPONSE);
            errorCode = MSG_OK;
            response->count = (uint8_t)count;
            response->result = MSG_OK;
            Msg_AddResponse(msgId,
                    (int)(sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T) + (sizeof(STORAGE_TYPE) * response->count)),
                    (uint8_t*)response);
        }
        else {
            errorCode = MSG_ERR_INVALID_PARAMETER;
        }
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t GetConfigHandler(uint8_t msgId, int len, const uint8_t * pPayload)
{
    (void)len; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    (void)pPayload; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    const MEMORY_CONFIG_T * config = Memory_GetConfig();
    APP_MSG_RESPONSE_GETCONFIG_T response;
    response.result = MSG_OK;
    response.configTime = config->time;
    response.currentTime = (uint32_t)Chip_RTC_Time_GetValue(NSS_RTC);
    response.interval = config->sleepTime;
    response.maxCount = config->maxSampleCount;
    response.validMinimum = config->validMinimum;
    response.validMaximum = config->validMaximum;
    response.count = (uint16_t)Storage_GetCount();
    response.valid = config->valid;
    Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);
    return MSG_OK;
}

static uint32_t SetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_SETCONFIG_T)) {
        const APP_MSG_CMD_SETCONFIG_T * command = (const APP_MSG_CMD_SETCONFIG_T *)pPayload;
        MSG_RESPONSE_RESULTONLY_T response;
        response.result = MSG_OK;

        /* First priority: handle the RTC adjustments. */
        Chip_RTC_Time_SetValue(NSS_RTC, (int)command->currentTime);
        if (command->interval == 0) {
            Timer_StopMeasurementTimeout();
        }
        else {
            Timer_StartMeasurementTimeout((int)command->interval);
        }

        /* Second priority: generate a response. */
        Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);

        /* Lowest priority: housekeeping. */
        Storage_Reset(false);
        Memory_ResetConfig();
        Memory_SetConfigTime(command->currentTime);
        Memory_SetLogging(command->interval != 0, false);
        Memory_SetConfigSleepTime(command->interval, command->limitCount != 0);
        Memory_SetConfigValidInterval(command->validMinimum, command->validMaximum);
        errorCode = MSG_OK;
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t MeasureTemperatureHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_MEASURETEMPERATURE_T)) {
        const APP_MSG_CMD_MEASURETEMPERATURE_T * command = (const APP_MSG_CMD_MEASURETEMPERATURE_T *)pPayload;
        if ((command->resolution >= TSEN_7BITS) && (command->resolution <= TSEN_12BITS)) {
            MSG_RESPONSE_RESULTONLY_T response;
            int value = TMeas_Measure(command->resolution, TMEAS_FORMAT_CELSIUS, false, 1 /* Value used in App_TmeasCb */);
            if (value == TMEAS_ERROR) {
                response.result = (uint32_t)TMEAS_ERROR;
            }
            else {
                response.result = MSG_OK;
            }
            Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);
            errorCode = MSG_OK;
        }
        else {
            errorCode = MSG_ERR_INVALID_PARAMETER;
        }
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

/* -------------------------------------------------------------------------------- */

static bool ResponseCb(int responseLength, const uint8_t* responseData)
{
    static unsigned char sLocale[] = "en";
#if !defined(MIME)
    #error MIME not defined. Define MIME in your Project settings.
    #error Under LPCXPresso: Project > Properties > C/C++ Build > Settings > Tool Settings > MCU C Compiler > Symbols
    #error Add a define similar to "MIME=\"tlogger/demo.nhs.nxp\"" (without surrounding unescaped quotes)
    #error Add this define to all build configurations.
#endif
    static unsigned char sMime[] = MIME;

    __attribute__ ((section(".noinit")))
    static uint8_t sGetVersionResponse[2 + sizeof(MSG_RESPONSE_GETVERSION_T)];

    __attribute__ ((section(".noinit"))) __attribute__((aligned (4)))
    static uint8_t sNdefInstance[NDEFT2T_INSTANCE_SIZE];

    __attribute__ ((section(".noinit"))) __attribute__((aligned (4)))
    static uint8_t sData[NFC_SHARED_MEM_BYTE_SIZE];

    NDEFT2T_CREATE_RECORD_INFO_T recordInfo;
    bool success = sAcceptResponse;

    /* A GetConfig response is always accompanied by a get version response and text record. This is a deviation from
     * the strict command/response foreseen when using the msg mod, but helps in this case to provide an initial message
     * with all status info at once.
     * During init - AppMsgInit() - it is ensured a get version response is generated. That response is stored here,
     * to be used for all subsequent received get config responses.
     */
    if ((MSG_ID_T)responseData[0] == MSG_ID_GETVERSION) {
        ASSERT(responseLength == 2 + sizeof(MSG_RESPONSE_GETVERSION_T));
        memcpy(&sGetVersionResponse, responseData, (size_t)responseLength);
        success = true; /* Avoid this to be stored in the internal response buffer of mod msg. */
    }

    if (sAcceptResponse) {
        sAcceptResponse = false;
        NDEFT2T_CreateMessage(sNdefInstance, sData, sizeof(sData), false);

        if ((APP_MSG_ID_T)responseData[0] == APP_MSG_ID_GETCONFIG) {

            /* Append a mime record with the stored version info. */
            recordInfo.shortRecord = true;
            recordInfo.pString = sMime;
            success &= NDEFT2T_CreateMimeRecord(sNdefInstance, &recordInfo);
            if (success) {
                success = NDEFT2T_WriteRecordPayload(sNdefInstance, sGetVersionResponse, sizeof(sGetVersionResponse));
                if (success) {
                    NDEFT2T_CommitRecord(sNdefInstance);
                }
            }

            /* Append a text record, discarded if the message is handled by the app, but shown by the OS otherwise. */
            recordInfo.shortRecord = true;
            recordInfo.pString = sLocale;
            success &= NDEFT2T_CreateTextRecord(sNdefInstance, &recordInfo);
            if (success) {
                success = NDEFT2T_WriteRecordPayload(sNdefInstance, Text_GetState(), TEXT_STATUS_LENGTH);
                if (success) {
                    NDEFT2T_CommitRecord(sNdefInstance);
                }
            }
        }

        /* Append a mime record with the just received response */
        recordInfo.shortRecord = false;
        recordInfo.pString = sMime;
        success &= NDEFT2T_CreateMimeRecord(sNdefInstance, &recordInfo);
        if (success) {
            success = NDEFT2T_WriteRecordPayload(sNdefInstance, responseData, responseLength);
            if (success) {
                NDEFT2T_CommitRecord(sNdefInstance);
            }
        }

        if (success) {
            NDEFT2T_CommitMessage(sNdefInstance);
        }
    }

    return success;
}

/* ------------------------------------------------------------------------- */

void AppMsgInit(bool reuseKeys)
{
    (void)reuseKeys; /* Ignore argument; there is nothing to reuse. */
    Msg_Init();
    Msg_SetResponseCb(ResponseCb);

    /* Take the initiative: start nfc communication by providing APP_MSG_ID_GETCONFIG and MSG_CMD_ID_GETVERSION responses. */
    uint8_t command[2] = {0, 0};
    command[0] = MSG_ID_GETVERSION;
    Msg_HandleCommand(2, command);
    command[0] = APP_MSG_ID_GETCONFIG;
    AppMsgHandleCommand(2, command);
}

void AppMsgHandleCommand(int cmdLength, const uint8_t* cmdData)
{
    sAcceptResponse = true;
    Msg_HandleCommand(cmdLength, cmdData);
}

void AppMsgHandlerSendMeasureTemperatureResponse(bool success, int16_t temperature)
{
    APP_MSG_RESPONSE_MEASURETEMPERATURE_T response;
    response.result = success ? MSG_OK : APP_MSG_ERR_TSEN;
    response.temperature = temperature;
    Msg_AddResponse(APP_MSG_ID_MEASURETEMPERATURE, sizeof(response), (uint8_t*)&response);
}
